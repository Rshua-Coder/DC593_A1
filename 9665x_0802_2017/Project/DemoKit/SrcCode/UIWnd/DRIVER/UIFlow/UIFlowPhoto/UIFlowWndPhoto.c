//This source code is generated by UI Designer Studio.

#include "UIFramework.h"
#include "UIFrameworkExt.h"
#include "NVTToolCommand.h"
#include "UIFlowWndPhotoRes.c"
#include "UIDisplay.h"
#include "UIFlow.h"
#include "ide.h"
#if(LOW_POWER_TIMELAPSE_REC == ENABLE)
#include "rtc.h"
#endif
#if (_CALIBRATION_MODE_ == ENABLE)
#include "EngineerMode.h"
#endif

#define FD_FRAME_RATE               3//10   //(10frame/30fps) = 333ms = update time

#define THIS_DBGLVL         2 //0=OFF, 1=ERROR, 2=TRACE
///////////////////////////////////////////////////////////////////////////////
#define __MODULE__          UIFlowWndPhoto
#define __DBGLVL__          ((THIS_DBGLVL>=PRJ_DBG_LVL)?THIS_DBGLVL:PRJ_DBG_LVL)
#define __DBGFLT__          "*" //*=All, [mark]=CustomClass
//#define __DBGFLT__          "[cap]"
//#define __DBGFLT__          "[fd]"
//#define __DBGFLT__          "[io]"
#include "DebugModule.h"
//---------------------FlowPhotoCtrl Global Variables----------


//-----------------------------------------------------------------------------
// UIFlowWndPhoto User Definitions
//-----------------------------------------------------------------------------
// Photo mode key mask
#define PHOTO_KEY_PRESS_MASK        (FLGKEY_KEY_MASK_DEFAULT)
#define PHOTO_KEY_RELEASE_MASK      (FLGKEY_KEY_MASK_DEFAULT)
#define PHOTO_KEY_CONTINUE_MASK     FLGKEY_KEY_CONT_MASK_DEFAULT

static UINT32 g_uiMaskKeyPress      = PHOTO_KEY_PRESS_MASK;
static UINT32 g_uiMaskKeyRelease    = PHOTO_KEY_RELEASE_MASK;
static UINT32 g_uiMaskKeyContinue   = PHOTO_KEY_CONTINUE_MASK;

static UINT32 g_uiSelfTimerID       = NULL_TIMER;
static UINT32 g_uiQviewTimerID      = NULL_TIMER;
static volatile BOOL g_bRedLEDOn    = FALSE;
//static void UIFlowWndPhoto_SetToQuickView(AlgMsgInfo *pAlgInfo);


//---------------------UIFlowWndPhotoCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndPhoto)
CTRL_LIST_ITEM(UIFlowWndPhoto_StaticICN_DSCMode)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_Selftimer)
CTRL_LIST_ITEM(UIFlowWndPhoto_StaticTXT_FreePic)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_EV)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_ISO)
CTRL_LIST_ITEM(UIFlowWndPhoto_StaticTXT_Size)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_AntiShaking)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_WB)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_FD)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_Quality)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_Storage)
CTRL_LIST_ITEM(UIFlowWndPhoto_StaticTXT_DZoom)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_Battery)
CTRL_LIST_ITEM(UIFlowWndPhoto_StaticTXT_SelftimerCnt)
CTRL_LIST_ITEM(UIFlowWndPhoto_PNL_Histogram)
CTRL_LIST_ITEM(UIFlowWndPhoto_PNL_FDFrame)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_ContinueShot)
CTRL_LIST_END

//----------------------UIFlowWndPhotoCtrl Event---------------------------
INT32 UIFlowWndPhoto_OnOpen(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnClose(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnUpdateInfo(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyUp(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyDown(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyLeft(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyRight(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyShutter1(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyShutter2(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyZoomin(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyZoomout(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyEnter(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyMenu(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyMode(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyPlayback(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnChildClose(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnStorageInit(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnStorageChange(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnBattery(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnBatteryLow(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnTimer(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnDZoomStepChange(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnFocusEnd(VControl *, UINT32, UINT32 *);
//INT32 UIFlowWndPhoto_OnFdEnd(VControl *, UINT32, UINT32 *);
//INT32 UIFlowWndPhoto_OnSdEnd(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(UIFlowWndPhoto)
EVENT_ITEM(NVTEVT_OPEN_WINDOW,UIFlowWndPhoto_OnOpen)
EVENT_ITEM(NVTEVT_CLOSE_WINDOW,UIFlowWndPhoto_OnClose)
EVENT_ITEM(NVTEVT_UPDATE_INFO,UIFlowWndPhoto_OnUpdateInfo)
EVENT_ITEM(NVTEVT_KEY_UP,UIFlowWndPhoto_OnKeyUp)
EVENT_ITEM(NVTEVT_KEY_DOWN,UIFlowWndPhoto_OnKeyDown)
EVENT_ITEM(NVTEVT_KEY_LEFT,UIFlowWndPhoto_OnKeyLeft)
EVENT_ITEM(NVTEVT_KEY_RIGHT,UIFlowWndPhoto_OnKeyRight)
EVENT_ITEM(NVTEVT_KEY_SHUTTER1,UIFlowWndPhoto_OnKeyShutter1)
EVENT_ITEM(NVTEVT_KEY_SHUTTER2,UIFlowWndPhoto_OnKeyShutter2)
EVENT_ITEM(NVTEVT_KEY_ZOOMIN,UIFlowWndPhoto_OnKeyZoomin)
EVENT_ITEM(NVTEVT_KEY_ZOOMOUT,UIFlowWndPhoto_OnKeyZoomout)
EVENT_ITEM(NVTEVT_KEY_ENTER,UIFlowWndPhoto_OnKeyEnter)
EVENT_ITEM(NVTEVT_KEY_MENU,UIFlowWndPhoto_OnKeyMenu)
EVENT_ITEM(NVTEVT_KEY_MODE,UIFlowWndPhoto_OnKeyMode)
EVENT_ITEM(NVTEVT_KEY_PLAYBACK,UIFlowWndPhoto_OnKeyPlayback)
EVENT_ITEM(NVTEVT_CHILD_CLOSE,UIFlowWndPhoto_OnChildClose)
EVENT_ITEM(NVTEVT_STORAGE_INIT,UIFlowWndPhoto_OnStorageInit)
EVENT_ITEM(NVTEVT_STORAGE_CHANGE,UIFlowWndPhoto_OnStorageChange)
EVENT_ITEM(NVTEVT_BATTERY,UIFlowWndPhoto_OnBattery)
EVENT_ITEM(NVTEVT_BATTERY_LOW,UIFlowWndPhoto_OnBatteryLow)
EVENT_ITEM(NVTEVT_TIMER,UIFlowWndPhoto_OnTimer)
EVENT_ITEM(NVTEVT_CB_ZOOM,UIFlowWndPhoto_OnDZoomStepChange)
EVENT_ITEM(NVTEVT_CB_FOCUSEND,UIFlowWndPhoto_OnFocusEnd)
//EVENT_ITEM(NVTEVT_CB_FDEND,UIFlowWndPhoto_OnFdEnd)
//EVENT_ITEM(NVTEVT_CB_SDEND,UIFlowWndPhoto_OnSdEnd)
EVENT_END

static void UIFlowWndPhoto_OnQVStart(void);
static void UIFlowWndPhoto_OnFdEnd(void);
//static void UIFlowWndPhoto_OnSdEnd(void);


static void UIFlowWndPhoto_OnExeSetImageRation(void)
{
    if (UI_GetData(FL_PHOTO_SIZE)==PHOTO_SIZE_2MHD)
    {
         Ux_SendEvent(&CustomPhotoObjCtrl,NVTEVT_EXE_IMAGE_RATIO,1,IMAGERATIO_16_9);
    } else {
         Ux_SendEvent(&CustomPhotoObjCtrl,NVTEVT_EXE_IMAGE_RATIO,1,IMAGERATIO_4_3);
    }
}

static void UIFlowWndPhoto_InitCfgSetting(void)
{

    Ux_SendEvent(&CustomPhotoObjCtrl,   NVTEVT_EXE_SELFTIMER,   1, SysGetFlag(FL_SELFTIMER));
    Ux_SendEvent(&CustomPhotoObjCtrl,   NVTEVT_EXE_QUALITY,     1,  SysGetFlag(FL_QUALITY));
    Ux_SendEvent(&CustomPhotoObjCtrl,   NVTEVT_EXE_ISO,         1, SysGetFlag(FL_ISO));
    Ux_SendEvent(&CustomPhotoObjCtrl,   NVTEVT_EXE_EV,          1, SysGetFlag(FL_EV));
    Ux_SendEvent(&CustomPhotoObjCtrl,   NVTEVT_EXE_WB,          1, SysGetFlag(FL_WB));
    Ux_SendEvent(&CustomPhotoObjCtrl,   NVTEVT_EXE_COLOR,       1, SysGetFlag(FL_COLOR_EFFECT));
    Ux_SendEvent(&CustomPhotoObjCtrl,   NVTEVT_EXE_SHARPNESS,   1,  SysGetFlag(FL_SHARPNESS));
    Ux_SendEvent(&CustomPhotoObjCtrl,   NVTEVT_EXE_FD,          1,  SysGetFlag(FL_FD));
    Ux_SendEvent(&CustomPhotoObjCtrl,   NVTEVT_EXE_DATE_PRINT,  1,  SysGetFlag(FL_DATE_STAMP));
    Ux_SendEvent(&CustomPhotoObjCtrl,   NVTEVT_EXE_SIZE,        1,  SysGetFlag(FL_PHOTO_SIZE));

    UIFlowWndPhoto_OnExeSetImageRation();

    // set FL_CONTINUE_SHOT to off
    SysSetFlag(FL_CONTINUE_SHOT,CONTINUE_SHOT_OFF);
}

static void FlowPhoto_InitStartupFuncs(void)
{
 UINT32 StartFunc = 0;

    StartFunc |=UIAPP_PHOTO_AE;
    StartFunc |=UIAPP_PHOTO_AWB;

    Ux_SendEvent(&CustomPhotoObjCtrl,NVTEVT_EXE_START_FUNC,2,StartFunc ,UIAPP_PHOTO_NOWAITIDLE);
}

static INT32 UIFlowWndPhoto_OnExeCapture(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32 uiEvtKeyAct = 0;

    if(paramNum > 0)
        uiEvtKeyAct = paramArray[0];

    switch(uiEvtKeyAct)
    {
        case NVTEVT_KEY_PRESS:
        {
            switch (gPhotoData.State)
            {
              case PHOTO_ST_VIEW:
                /* Check if in quick review process */
                if(SysGetFlag(FL_QUICK_REVIEW) != QUICK_REVIEW_0SEC)
                {
                    if(g_uiQviewTimerID != NULL_TIMER)
                    {
                        GxTimer_StopTimer(&g_uiQviewTimerID);
                        //g_bQviewTimerStart = FALSE;

                        // unloce AE/AWB
                        FlowPhoto_InitStartupFuncs();

                        /* Set to preview mode */
                        UI_Show(UI_SHOW_PREVIEW, TRUE);

                        /* close quick view image */
                        UI_Show(UI_SHOW_QUICKVIEW, FALSE);

                        /* Resume key after quick view completed */
                        Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);
                        Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);

                        /* Update window info */
                        FlowPhoto_UpdateIcons(TRUE);
                        return NVTEVT_CONSUME;
                    }
                }

                /* Check capture prerequisite */
                if(FlowPhoto_IsStorageErr() == TRUE)
                {
                    debug_err(("UIFlowWndPhoto_OnKeyShutter2: Card or memory full!\r\n"));
                    gPhotoData.State= PHOTO_ST_WARNING_MENU;
                    return NVTEVT_CONSUME;
                }
                if (GetBatteryLevel() == BATTERY_EXHAUSTED)
                {
                    debug_err(("UIFlowWndPhoto_OnKeyShutter2: Battery is too low!\r\n"));
                    return NVTEVT_CONSUME;
                }

                // check free pic number
                if (SysGetFlag(FL_CONTINUE_SHOT) == CONTINUE_SHOT_ON) {
                    if(FlowPhoto_GetFreePicNum() < 2)
                    {
                        UINT32 uiMsg = 0;

                        uiMsg = (UI_GetData(FL_CardStatus) == CARD_REMOVED)? UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD : UIFlowWndWrnMsg_StatusTXT_Msg_STRID_CARD_FULL;
                        gPhotoData.State= PHOTO_ST_WARNING_MENU;
                        Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,uiMsg,FLOWWRNMSG_TIMER_2SEC);
                        return NVTEVT_CONSUME;
                    }
                }

                switch (SysGetFlag(FL_SELFTIMER))          // set capture mode by system flag
                {
                case SELFTIMER_2SEC:
                    /* Suspend all keys, except S2 key while selftimer started */
                    Input_SetKeyMask(KEY_PRESS, FLGKEY_ENTER);
                    FlowPhoto_IconDrawSelftimerTime(&UIFlowWndPhoto_StaticTXT_SelftimerCntCtrl,2);
                    gPhotoData.SelfTimerCount = 20;              // set time counter
                    gPhotoData.State = PHOTO_ST_SELFTIMER;  // set working state to self-timer state
                    //KeyScan_EnableLEDToggle(KEYSCAN_LED_GREEN, TRUE);
                    UISound_Play(DEMOSOUND_SOUND_KEY_TONE);
                    if (g_uiSelfTimerID == NULL_TIMER)
                    {
                        g_uiSelfTimerID = GxTimer_StartTimer(100, NVTEVT_01SEC_TIMER, CONTINUE);
                    }
                    break;
                case SELFTIMER_5SEC:
                    /* Suspend all keys, except S2 key while selftimer started */
                    Input_SetKeyMask(KEY_PRESS, FLGKEY_ENTER);
                    FlowPhoto_IconDrawSelftimerTime(&UIFlowWndPhoto_StaticTXT_SelftimerCntCtrl,5);
                    gPhotoData.SelfTimerCount = 50;         // set time counter
                    gPhotoData.State = PHOTO_ST_SELFTIMER;  // set working state to self-timer state
                    //KeyScan_EnableLEDToggle(KEYSCAN_LED_GREEN, TRUE);
                    UISound_Play(DEMOSOUND_SOUND_KEY_TONE);
                    if (g_uiSelfTimerID == NULL_TIMER)
                    {
                        g_uiSelfTimerID = GxTimer_StartTimer(100, NVTEVT_01SEC_TIMER, CONTINUE);
                    }
                    break;
                case SELFTIMER_10SEC:
                    /* Suspend all keys, except S2 key while selftimer started */
                    Input_SetKeyMask(KEY_PRESS, FLGKEY_ENTER);
                    FlowPhoto_IconDrawSelftimerTime(&UIFlowWndPhoto_StaticTXT_SelftimerCntCtrl,10);
                    gPhotoData.SelfTimerCount = 100;        // set time counter
                    gPhotoData.State = PHOTO_ST_SELFTIMER;  // set working state to self-timer state
                    //#NT#2012/8/1#Philex - begin
                    //KeyScan_EnableLEDToggle(KEYSCAN_LED_GREEN, TRUE);
                    UISound_Play(DEMOSOUND_SOUND_KEY_TONE);
                    //#NT#2012/8/1#Philex - begin
                    if (g_uiSelfTimerID == NULL_TIMER)
                    {
                        g_uiSelfTimerID = GxTimer_StartTimer(100, NVTEVT_01SEC_TIMER, CONTINUE);
                    }
                    break;
                default:
                    /* Suspend all keys before sending capture command */
                    Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);
                    Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);

                    /* Clear the whole OSD screen */
                    UxCtrl_SetAllChildShow(pCtrl,FALSE);

                    gPhotoData.State = PHOTO_ST_CAPTURE;    // enter capture state
                    FlowPhoto_DoCapture();                  // do capture directly
                    break;
                 }
                break;
                case PHOTO_ST_SELFTIMER:
                     gPhotoData.State = PHOTO_ST_VIEW;
                     gPhotoData.SelfTimerCount = 0;
                     //KeyScan_EnableLEDToggle(KEYSCAN_LED_GREEN, FALSE);
                     FlowPhoto_IconHideSelftimer(&UIFlowWndPhoto_StaticTXT_SelftimerCntCtrl);
                     // resume press mask to default
                     Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);
                    break;
            }
            break;
        }

        case NVTEVT_KEY_RELEASE:
        {
            //Rsvd
            break;
        }

        default:
            debug_err(("UIFlowWndPhoto_OnKeyShutter2: Unknown evt 0x%x\r\n", uiEvtKeyAct));
            break;
    }
    return NVTEVT_CONSUME;
}

static INT32 UIFlowWndPhoto_OnExeZoomIn(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32 uiEvtKeyAct = 0;

    if(paramNum > 0)
        uiEvtKeyAct = paramArray[0];

    switch(uiEvtKeyAct)
    {
        case NVTEVT_KEY_PRESS:
        case NVTEVT_KEY_CONTINUE:
            if (DZOOM_IDX_GET() > DZOOM_IDX_MAX())
              {
                Ux_SendEvent(&CustomPhotoObjCtrl,NVTEVT_EXE_ZOOM,2, UI_ZOOM_CTRL_STOP, UI_GetData(FL_Dzoom));
                gPhotoData.State &= ~PHOTO_ST_ZOOM;
                return NVTEVT_CONSUME;
              }
            switch(gPhotoData.State)
            {
              case PHOTO_ST_VIEW:
              case PHOTO_ST_VIEW|PHOTO_ST_ZOOM:
                   /* set Digital Zoom interface */
                   UI_SetData(FL_ZoomIFIndex,ZOOM_IF_DIGITAL);
                   /*
                    * Suspend all keys while keep ZoomIn pressed.
                    * Gotta resume them after ZoomIn key released.
                    */
                   Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);
                   FlowPhoto_ForceLockFdSd();
                   gPhotoData.State |= PHOTO_ST_ZOOM;
                   Ux_SendEvent(&CustomPhotoObjCtrl,NVTEVT_EXE_ZOOM,2, UI_ZOOM_CTRL_IN,UI_GetData(FL_Dzoom));
                break;
            }
            break;

        case NVTEVT_KEY_RELEASE:
             Ux_SendEvent(&CustomPhotoObjCtrl,NVTEVT_EXE_ZOOM,2, UI_ZOOM_CTRL_STOP,UI_GetData(FL_Dzoom));
             gPhotoData.State &= ~PHOTO_ST_ZOOM;
             FlowPhoto_SetFdSdProc(FlowPhoto_GetSDStatus());
             /* Resume keys after ZoomIn released */
             Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);
            break;

        default:
            debug_err(("UIFlowWndPhoto_OnKeyZoomin: Unknown evt 0x%x\r\n", uiEvtKeyAct));
            break;
    }

    return NVTEVT_CONSUME;
}

static INT32 UIFlowWndPhoto_OnExeZoomOut(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
 UINT32 uiEvtKeyAct = 0;

    if(paramNum > 0)
        uiEvtKeyAct = paramArray[0];

    switch(uiEvtKeyAct)
    {
        case NVTEVT_KEY_PRESS:
        case NVTEVT_KEY_CONTINUE:

            switch(gPhotoData.State)
            {
              case PHOTO_ST_VIEW:
              case PHOTO_ST_VIEW|PHOTO_ST_ZOOM:
                   /* set Digital Zoom interface */
                   UI_SetData(FL_ZoomIFIndex,ZOOM_IF_DIGITAL);
                   /*
                    * Suspend all keys while keep ZoomIn pressed.
                    * Gotta resume them after ZoomIn key released.
                    */
                   Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);
                   FlowPhoto_ForceLockFdSd();
                   gPhotoData.State |= PHOTO_ST_ZOOM;
                   Ux_SendEvent(&CustomPhotoObjCtrl,NVTEVT_EXE_ZOOM,2, UI_ZOOM_CTRL_OUT,UI_GetData(FL_Dzoom));
                break;
            }
            break;

        case NVTEVT_KEY_RELEASE:
             Ux_SendEvent(&CustomPhotoObjCtrl,NVTEVT_EXE_ZOOM,2, UI_ZOOM_CTRL_STOP, UI_GetData(FL_Dzoom));
             gPhotoData.State &= ~PHOTO_ST_ZOOM;
             FlowPhoto_SetFdSdProc(FlowPhoto_GetSDStatus());
             /* Resume keys after ZoomIn released */
             Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);
            break;

        default:
            debug_err(("UIFlowWndPhoto_OnKeyZoomOut: Unknown evt 0x%x\r\n", uiEvtKeyAct));
            break;
    }

    return NVTEVT_CONSUME;
}


INT32 UIFlowWndPhoto_OnOpen(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{


    UIFlowWndPhoto_InitCfgSetting();
    FlowPhoto_InitStartupFuncs();

    /* Init window key mask variables & set key press/release/continue mask */
    gPhotoData.State = PHOTO_ST_VIEW;
    g_uiMaskKeyPress = PHOTO_KEY_PRESS_MASK;
    g_uiMaskKeyRelease = PHOTO_KEY_RELEASE_MASK;
    g_uiMaskKeyContinue = PHOTO_KEY_CONTINUE_MASK;
    Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);

    Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);
    Input_SetKeyMask(KEY_RELEASE, g_uiMaskKeyRelease);
    Input_SetKeyMask(KEY_CONTINUE, g_uiMaskKeyContinue);

    gPhotoData.SysTimeCount = 0;
    /* Update window info */
    FlowPhoto_UpdateIcons(TRUE);
    /* set FD/SD feature */
    FlowPhoto_SetFdSdProc(TRUE);
#if(LOW_POWER_TIMELAPSE_REC == ENABLE)

    DBG_DUMP("RTC Timelape: rtc_isPWRAlarm() = %d =====\r\n",rtc_isPWRAlarm());

    //if(UI_GetData(FL_LOW_POWER_TIMELAPSE_REC)&& rtc_isPWRAlarm())
    if(rtc_isPWRAlarm())
    {

        //UIFlowDCF_TimelapseRecUpdateName();
        //NH_FileDB_SetRootFolder("TMLPS");
        // Wait until AE/AWB are stable.
        IPC_WaitVD(FALSE,IPL_ID_1);
        IPC_WaitVD(FALSE,IPL_ID_1);
        IPC_WaitVD(FALSE,IPL_ID_1);
        // press enter key to capture
        Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
    }
#endif
    Ux_DefaultEvent(pCtrl,NVTEVT_OPEN_WINDOW,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnClose(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{

    // stop SelTimerID/QViewTimerID
    if (g_uiSelfTimerID != NULL_TIMER)
    {
        GxTimer_StopTimer(&g_uiSelfTimerID);
    }

    if (g_uiQviewTimerID != NULL_TIMER)
    {
        GxTimer_StopTimer(&g_uiQviewTimerID);
    }

    /* Once close photo window, reset selftimer to off state */
//    SysSetFlag(FL_SELFTIMER, SELFTIMER_OFF);

    g_bRedLEDOn = FALSE;
    //KeyScan_TurnOffLED(KEYSCAN_LED_RED);

    gPhotoData.QuickViewCount = 0;
    gPhotoData.SelfTimerCount = 0;

    FlowPhoto_InitStartupFuncs();

    /* Reset key press/release/continue mask to default */
    Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);

    Ux_DefaultEvent(pCtrl,NVTEVT_CLOSE_WINDOW,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnUpdateInfo(VControl * pCtrl, UINT32 paramNum, UINT32 * paramArray)
{

    switch (pPhotoExeInfo->CallBackEvent)
    {
       case UIAPPPHOTO_CB_QVSTART:
            UIFlowWndPhoto_OnQVStart();
        break;
       case UIAPPPHOTO_CB_JPGOK:
        break;
       case UIAPPPHOTO_CB_FSTOK:
            /* Update window info */
            FlowPhoto_UpdateIcons(TRUE);
#if(LOW_POWER_TIMELAPSE_REC == ENABLE)
            {
            extern void SetupExe_OnLowPowerTimelapseRec(void);
            DBG_DUMP("UIAPPPHOTO_CB_FSTOK>>>\r\n");
            SetupExe_OnLowPowerTimelapseRec();
            //if (UI_GetData(FL_LOW_POWER_TIMELAPSE_REC)&& rtc_isPWRAlarm())
            //    Ux_SendEvent(&CustomPhotoObjCtrl, NVTEVT_EXE_LOWPOWER_TIMELAPSE_REC, 1, UI_GetData(FL_LOW_POWER_TIMELAPSE_REC));
            }
#endif
        break;
       case UIAPPPHOTO_CB_CAPTUREEND:
            // unloce AE/AWB
            FlowPhoto_InitStartupFuncs();
        break;
       case UIAPPPHOTO_CB_FDEND:
        UIFlowWndPhoto_OnFdEnd();
        break;
       case UIAPPPHOTO_CB_SDEND:
        if (SysGetFlag(FL_FD) == FD_SMILE)
        {
           if ((gPhotoData.State!=PHOTO_ST_CAPTURE)&&(gPhotoData.QuickViewCount==0))
            {
                /* Enable FD frame show */
                UxCtrl_SetShow(&UIFlowWndPhoto_PNL_FDFrameCtrl,TRUE);
                UI_Show(UI_SHOW_INFO, FALSE); //FD layer
                Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);
            }
        }
        break;
    }

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnKeyUp(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return UIFlowWndPhoto_OnExeZoomIn(pCtrl, paramNum, paramArray);
}
INT32 UIFlowWndPhoto_OnKeyDown(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return UIFlowWndPhoto_OnExeZoomOut(pCtrl, paramNum, paramArray);
}
INT32 UIFlowWndPhoto_OnKeyLeft(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
 UINT32  uiKeyAct;
 UINT32 uiEV;

   uiKeyAct = paramArray[0];

    switch(uiKeyAct)
    {
    case NVTEVT_KEY_PRESS:
         switch(gPhotoData.State)
         {
            case PHOTO_ST_VIEW:
            case PHOTO_ST_VIEW|PHOTO_ST_ZOOM:
                uiEV = SysGetFlag(FL_EV);
                if (uiEV==EV_N20)
                {
                    SysSetFlag(FL_EV,EV_P20);
                } else {
                    SysSetFlag(FL_EV,++uiEV);
                }

                Ux_SendEvent(&CustomPhotoObjCtrl,NVTEVT_EXE_EV,1, SysGetFlag(FL_EV));
                FlowPhoto_IconDrawEV(&UIFlowWndPhoto_StatusICN_EVCtrl);
            break;
         }
        break;
    }
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnKeyRight(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
 UINT32  uiKeyAct;

   uiKeyAct = paramArray[0];

    switch (uiKeyAct)
    {
     case NVTEVT_KEY_PRESS:
        if (g_bRedLEDOn ==FALSE) {
            g_bRedLEDOn =TRUE;
            //KeyScan_TurnOnLED(KEYSCAN_LED_RED);
        } else {
            g_bRedLEDOn = FALSE;
            //KeyScan_TurnOffLED(KEYSCAN_LED_RED);
        }
        break;
    }
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnKeyShutter1(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnKeyShutter2(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return UIFlowWndPhoto_OnExeCapture(pCtrl,paramNum,paramArray);
}
INT32 UIFlowWndPhoto_OnKeyZoomin(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return UIFlowWndPhoto_OnExeZoomIn(pCtrl, paramNum, paramArray);
}
INT32 UIFlowWndPhoto_OnKeyZoomout(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return UIFlowWndPhoto_OnExeZoomOut(pCtrl, paramNum, paramArray);
}
INT32 UIFlowWndPhoto_OnKeyEnter(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnKeyMenu(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiKeyAct;
    UINT32  uiSoundMask;

	static BOOL bKey_Continue = FALSE;
	static INT32 bKey_Continue_Count = -1;
		
    uiKeyAct = paramArray[0];

    switch(uiKeyAct)
    {
	    case NVTEVT_KEY_PRESS:
			bKey_Continue = FALSE;
			bKey_Continue_Count = 0;
		break;

		case NVTEVT_KEY_CONTINUE:
			bKey_Continue = TRUE;
			if(bKey_Continue_Count == -1)	break;
			bKey_Continue_Count ++ ;
			if(bKey_Continue_Count == 1){//change to playback mode
				Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);
		        Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);
		        Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);
		        Input_SetKeyMask(KEY_CONTINUE, FLGKEY_KEY_MASK_NULL);
		        Ux_SendEvent(&UISetupObjCtrl,NVTEVT_EXE_CHANGEDSCMODE,1,DSCMODE_CHGTO_NEXT);
			}
			else{
				//do nothing
			}
		break;
	
		case NVTEVT_KEY_RELEASE:
			if((bKey_Continue == FALSE) && (bKey_Continue_Count >= 0)){ //short press to menu 
		        switch(gPhotoData.State)
		        {
		        case PHOTO_ST_VIEW:
		            // enable shutter2 sound (shutter2 as OK key in menu)
		            uiSoundMask = Input_GetKeySoundMask(KEY_PRESS);
		            uiSoundMask |= FLGKEY_SHUTTER2;
		            Input_SetKeySoundMask(KEY_PRESS, uiSoundMask);

		            /* Force to lock FD/SD functions before opening Menu */
		            FlowPhoto_ForceLockFdSd();
		            Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);

		            // Set Tab menu to Photo menu
		            TM_SetMenu(&gPhotoMenu);
		            // Open common mix (Item + Option) menu
		            Ux_OpenWindow((VControl *)(&MenuCommonItemCtrl), 0);
		            gPhotoData.State = PHOTO_ST_MENU;
		            break;
		        }
    		}
			else if (bKey_Continue == TRUE){
				//do nothing
			}
			bKey_Continue_Count = -1;
	    break;
    }
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnKeyMode(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
 UINT32 uiKeyAct=NVTEVT_KEY_PRESS;

    if (paramNum==1)
    {
        uiKeyAct = paramArray[0];
    } else {
        return NVTEVT_CONSUME;
    }

    switch(uiKeyAct)
    {
     case NVTEVT_KEY_PRESS:
        Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);
        Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);
        Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);
        Input_SetKeyMask(KEY_CONTINUE, FLGKEY_KEY_MASK_NULL);

        Ux_SendEvent(&UISetupObjCtrl,NVTEVT_EXE_CHANGEDSCMODE,1,DSCMODE_CHGTO_NEXT);
        break;
    }

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnKeyPlayback(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    switch (gPhotoData.State)
    {
      case PHOTO_ST_VIEW:
      case (PHOTO_ST_VIEW|PHOTO_ST_ZOOM):
        Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);
        Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);
        Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);
        Input_SetKeyMask(KEY_CONTINUE, FLGKEY_KEY_MASK_NULL);

        Ux_SendEvent(&UISetupObjCtrl,NVTEVT_FORCETO_PLAYBACK_MODE,0);
        break;
    }

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnChildClose(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiSoundMask;

    /* Set key mask to self-original state */
    Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);
    Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);
    Input_SetKeyMask(KEY_RELEASE, g_uiMaskKeyRelease);
    Input_SetKeyMask(KEY_CONTINUE, g_uiMaskKeyContinue);

    switch (gPhotoData.State)
    {
      case PHOTO_ST_WARNING_MENU:
            if(paramNum > 0)
            {
                if(paramArray[0] == NVTRET_ENTER_MENU)
                {
                    /* Force to lock FD/SD functions before opening Menu */
                    FlowPhoto_ForceLockFdSd();
                    /* Create Menu window */
                    gPhotoData.State = PHOTO_ST_MENU;
                    TM_SetMenu(&gPhotoMenu);
                    Ux_OpenWindow(&MenuCommonItemCtrl, 0);
                    return NVTEVT_CONSUME;
                }
            }
            gPhotoData.State = PHOTO_ST_VIEW;
        break;

      case PHOTO_ST_MENU:
            // disable shutter2 sound
            uiSoundMask = Input_GetKeySoundMask(KEY_PRESS);
            uiSoundMask &= ~FLGKEY_SHUTTER2;
            Input_SetKeySoundMask(KEY_PRESS, uiSoundMask);

            gPhotoData.State = PHOTO_ST_VIEW;
            // set image ratio here
            UIFlowWndPhoto_OnExeSetImageRation();

            // unloce AE/AWB
            FlowPhoto_InitStartupFuncs();

            /* Set to preview mode */
            UI_Show(UI_SHOW_PREVIEW, TRUE);

            /* close quick view image */
            UI_Show(UI_SHOW_QUICKVIEW, FALSE);

            /* Resume key after normal capture completed */
            Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);

            /* Set FD/SD functions againg after exiting Menu */
            FlowPhoto_SetFdSdProc(TRUE);
            /* Update window info */
            FlowPhoto_UpdateIcons(TRUE);
        break;
    }

    Ux_DefaultEvent(pCtrl,NVTEVT_CHILD_CLOSE,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnStorageInit(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    #if (_CALIBRATION_MODE_ == ENABLE)
    // check if enter engineer mode
    if (EngineerMode_CheckEng())
    {
        Ux_SendEvent(0, NVTEVT_SYSTEM_MODE, 1, PRIMARY_MODE_MAIN);
    }
    #endif
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnStorageChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnBattery(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
 static volatile BOOL bBatteryOn = FALSE;

    UxState_SetData(&UIFlowWndPhoto_StatusICN_BatteryCtrl,STATE_CURITEM,GetBatteryLevel());
    if (KeyScan_IsACIn())
    {
        bBatteryOn = !bBatteryOn;
        UxCtrl_SetShow(&UIFlowWndPhoto_StatusICN_BatteryCtrl,bBatteryOn);
    } else {
        UxCtrl_SetShow(&UIFlowWndPhoto_StatusICN_BatteryCtrl,TRUE);
    }
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnBatteryLow(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_BATTERY_LOW, FLOWWRNMSG_TIMER_2SEC);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnTimer(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
 NVTEVT event;


    if(paramNum > 0)
    {
       event = paramArray[0];
    } else {
       return NVTEVT_CONSUME;
    }
    switch(event)
    {
      case NVTEVT_01SEC_TIMER:
        if (gPhotoData.QuickViewCount !=0)
        {
            gPhotoData.QuickViewCount--;
            if (gPhotoData.QuickViewCount == 0)
            {
                if (g_uiQviewTimerID != NULL_TIMER)
                {
                    GxTimer_StopTimer(&g_uiQviewTimerID);
                }

                /* reset state to PHOTO_ST_VIEW */
                gPhotoData.State = PHOTO_ST_VIEW;

                /* set FD/SD feature */
                FlowPhoto_SetFdSdProc(FALSE);

                /* Set to preview mode */
                UI_Show(UI_SHOW_PREVIEW, TRUE);

                /* close quick view image */
                UI_Show(UI_SHOW_QUICKVIEW, FALSE);

                /* Update window info */
                //FlowPhoto_UpdateIcons(TRUE);

                /* Resume key after normal capture completed */
                Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);

                Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);

                /* set DirID/FileID */
                {
                 UINT32 uhFilesysDirNum, uhFilesysFileNum;

                    DCF_GetNextID(&uhFilesysDirNum, &uhFilesysFileNum);
                    SysSetFlag(FL_DCF_DIR_ID, uhFilesysDirNum);
                    SysSetFlag(FL_DCF_FILE_ID, uhFilesysFileNum);
                }
            }
        }

        if (gPhotoData.SelfTimerCount != 0)
        {
            gPhotoData.SelfTimerCount--;
            if (gPhotoData.SelfTimerCount == 0)
            {
                if (g_uiSelfTimerID != NULL_TIMER)
                {
                    GxTimer_StopTimer(&g_uiSelfTimerID);
                }

                // stopping LED toggle
                //KeyScan_EnableLEDToggle(KEYSCAN_LED_GREEN, FALSE);
            }
            FlowPhoto_OnTimer01SecIndex();
        }
        break;
    }
    return NVTEVT_CONSUME;
}
static void UIFlowWndPhoto_OnQVStart(void)
{

    /* Set to quick review mode */
    UI_Show(UI_SHOW_QUICKVIEW, TRUE);
    switch(SysGetFlag(FL_QUICK_REVIEW))
        {
           case QUICK_REVIEW_2SEC:
             gPhotoData.QuickViewCount = 15;
            break;
           case QUICK_REVIEW_5SEC:
             gPhotoData.QuickViewCount = 45;
            break;
           case QUICK_REVIEW_0SEC:
             gPhotoData.QuickViewCount = 1;
            break;
        }
    if (g_uiQviewTimerID == NULL_TIMER)
    {
        /* Resume only S2 key while quick view timer started */
        Input_SetKeyMask(KEY_PRESS, FLGKEY_SHUTTER2);
        g_uiQviewTimerID = GxTimer_StartTimer(100, NVTEVT_01SEC_TIMER, CONTINUE);
    }
}

INT32 UIFlowWndPhoto_OnDZoomStepChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{

    /* Update Digital zoom icon */
    FlowPhoto_IconDrawDZoom(&UIFlowWndPhoto_StaticTXT_DZoomCtrl);

    return NVTEVT_CONSUME;
}

INT32 UIFlowWndPhoto_OnFocusEnd(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return NVTEVT_CONSUME;
}
static void UIFlowWndPhoto_OnFdEnd(void)
{
    if (SysGetFlag(FL_FD) != FD_OFF)
    {
        if ((gPhotoData.State!=PHOTO_ST_CAPTURE)&&(gPhotoData.QuickViewCount==0))
        {
            /* Enable FD frame show */
            UxCtrl_SetShow(&UIFlowWndPhoto_PNL_FDFrameCtrl,TRUE);

            /* Redraw all window OSD */
            UxCtrl_SetDirty(&UIFlowWndPhotoCtrl, TRUE);
        }
    }
}

#if 0
static void UIFlowWndPhoto_OnSdEnd(void)
{
 #define    SDCount 6
 static UINT32 uiSDCount=0;

    if (SysGetFlag(FL_SELFTIMER)==SELFTIMER_OFF)
    {
        if (uiSDCount++>=SDCount)
        {
            uiSDCount=0;
            Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
        }
    }
}
#endif
//----------------------UIFlowWndPhoto_StaticICN_DSCModeCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StaticICN_DSCMode)
EVENT_END

//----------------------UIFlowWndPhoto_StatusICN_SelftimerCtrl Event---------------------------
INT32 UIFlowWndPhoto_StatusICN_Selftimer_OnKeyLeft(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_Selftimer)
EVENT_ITEM(NVTEVT_KEY_LEFT,UIFlowWndPhoto_StatusICN_Selftimer_OnKeyLeft)
EVENT_END

INT32 UIFlowWndPhoto_StatusICN_Selftimer_OnKeyLeft(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    /* Increase item index */
    Ux_SendEvent(pCtrl,NVTEVT_NEXT_ITEM,0);
    /* Send exe to obj for handling (including set ui index) */
    Ux_SendEvent(&UIPhotoObjCtrl,NVTEVT_EXE_SELFTIMER,1,UxState_GetData(pCtrl,STATE_CURITEM));
    return NVTEVT_CONSUME;
}
//----------------------UIFlowWndPhoto_StaticTXT_FreePicCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StaticTXT_FreePic)
EVENT_END

//----------------------UIFlowWndPhoto_StatusICN_EVCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_EV)
EVENT_END

//----------------------UIFlowWndPhoto_StatusICN_ISOCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_ISO)
EVENT_END

//----------------------UIFlowWndPhoto_StaticTXT_SizeCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StaticTXT_Size)
EVENT_END

//----------------------UIFlowWndPhoto_StatusICN_AntiShakingCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_AntiShaking)
EVENT_END

//----------------------UIFlowWndPhoto_StatusICN_WBCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_WB)
EVENT_END

//----------------------UIFlowWndPhoto_StatusICN_FDCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_FD)
EVENT_END

//----------------------UIFlowWndPhoto_StatusICN_QualityCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_Quality)
EVENT_END

//----------------------UIFlowWndPhoto_StatusICN_StorageCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_Storage)
EVENT_END

//----------------------UIFlowWndPhoto_StaticTXT_DZoomCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StaticTXT_DZoom)
EVENT_END

//----------------------UIFlowWndPhoto_StatusICN_BatteryCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_Battery)
EVENT_END

//----------------------UIFlowWndPhoto_StaticTXT_SelftimerCntCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StaticTXT_SelftimerCnt)
EVENT_END

//---------------------UIFlowWndPhoto_PNL_HistogramCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndPhoto_PNL_Histogram)
CTRL_LIST_END

//----------------------UIFlowWndPhoto_PNL_HistogramCtrl Event---------------------------
INT32 UIFlowWndPhoto_PNL_Histogram_OnTimer(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_PNL_Histogram_OnRedraw(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(UIFlowWndPhoto_PNL_Histogram)
EVENT_ITEM(NVTEVT_TIMER,UIFlowWndPhoto_PNL_Histogram_OnTimer)
EVENT_ITEM(NVTEVT_REDRAW,UIFlowWndPhoto_PNL_Histogram_OnRedraw)
EVENT_END

INT32 UIFlowWndPhoto_PNL_Histogram_OnTimer(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_PNL_Histogram_OnRedraw(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return NVTEVT_CONSUME;
}
//---------------------UIFlowWndPhoto_PNL_FDFrameCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndPhoto_PNL_FDFrame)
CTRL_LIST_END

//----------------------UIFlowWndPhoto_PNL_FDFrameCtrl Event---------------------------
INT32 UIFlowWndPhoto_PNL_FDFrame_OnRedraw(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(UIFlowWndPhoto_PNL_FDFrame)
EVENT_ITEM(NVTEVT_REDRAW,UIFlowWndPhoto_PNL_FDFrame_OnRedraw)
EVENT_END

INT32 UIFlowWndPhoto_PNL_FDFrame_OnRedraw(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    #if _FD_FUNC_
    #define ANGLE_LEN    8
    #define ANGLE_INTER  4
    #define MAX_WIDTH    640
    #define MAX_HEIGHT   480
    #define MAX_FDNUM    36


    DC** pDCList = (DC**)paramArray[ONEVENT_PARAM_INDEX_SCREEN];
    UINT32 uiRectColor = _OSD_INDEX_WHITE;
    UINT32 i,Fdnumber,FDId;
    URECT  *prectOne, rectOne;
    prectOne = &rectOne;
    FDMSG_INFO  FdInfo;

    FD_GetRsltInfo(&FdInfo);
    Fdnumber = FdInfo.FaceDetectNum;
    if (Fdnumber > MAX_FDNUM)
    {
        Fdnumber = MAX_FDNUM;
    }
    if (SysGetFlag(FL_FD)==FD_OFF)
    {
        uiRectColor = _OSD_INDEX_TRANSPART;
    } else {
        uiRectColor = _OSD_INDEX_WHITE;
    }

    DBG_IND("[fd]localInfo->IsFDCleared =%d,Fdnumber=%d\r\n",localInfo->IsFDCleared,Fdnumber);
    DBG_IND("[fd]FDFrame_OnDraw color=%d, \r\n",uiRectColor);

    ide_setFDAllDis(0xFFFF);
    if(uiRectColor != _OSD_INDEX_TRANSPART)
    {
        for (i=0;i<Fdnumber;i++)
        {
            #if PHOTO_SET_IMAGE_RATIO
            // 16:9 image ratio
            if (UI_GetData(FL_PHOTO_SIZE) == UI_GetData(FL_PHOTO_SIZE))
            {
                prectOne->y = ((prectOne->y*3)>>2);
                prectOne->h =(( prectOne->h*3)>>2);
                prectOne->y+= 30;
            } // 4:3 image ratio
            else
            {
                prectOne->y = ((prectOne->y*8)/9);
                prectOne->h =(( prectOne->h*8)/9);
                prectOne->y+= 14;
            }
            #endif

            prectOne->x=(prectOne->x>>1)<<1;
            prectOne->w=(prectOne->w>>1)<<1;

            if (prectOne->x <2)
            {
                prectOne->x = 2;
            }
            if (prectOne->y <1)
            {
                prectOne->y = 1;
            }
            prectOne->x = FdInfo.FaceDetectRect[i].stx;
            prectOne->y = FdInfo.FaceDetectRect[i].sty;
            prectOne->w = FdInfo.FaceDetectRect[i].width;
            prectOne->h = FdInfo.FaceDetectRect[i].height;

            DBG_IND("[fd] %d ( %3d , %3d ; %3d , %3d )\r\n",
                        i,
                        prectOne->x,
                        prectOne->y,
                        prectOne->w,
                        prectOne->h);

            // draw FD frame
            FDId = (IDE_FD_0<<i);
            ide_setFDWinPos(FDId,prectOne->x<<1,prectOne->y);
            ide_setFDWinDim(FDId,prectOne->w<<1,prectOne->h);
            ide_setFDWinBord(FDId,4,2);
            ide_setFDColor(FDId, 0xFF, 0x80, 0x80);
            ide_setFDEn(FDId);
        }
    }
    ide_setLoad();
    #endif

    return NVTEVT_CONSUME;
}
//----------------------UIFlowWndPhoto_StatusICN_ContinueShotCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_ContinueShot)
EVENT_END




